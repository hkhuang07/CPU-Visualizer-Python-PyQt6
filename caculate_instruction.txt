# Addition Program
# Inputs: RAM[14] (Operand 1), RAM[15] (Operand 2)
# Output: RAM[13] (Result)
# (Đặt chương trình này bắt đầu từ RAM[0])

# Opcodes (giả định):
# LOAD_A: 0001xxxx
# LOAD_B: 0010xxxx
# STORE_A: 0011xxxx
# ADD_AB: 01011001
# HALT: 11110000

RAM[0]: 00011110  ; LOAD_A 14   ; Load Operand 1 (RAM[14]) into Register A
RAM[1]: 00101111  ; LOAD_B 15   ; Load Operand 2 (RAM[15]) into Register B
RAM[2]: 01011001  ; ADD_AB      ; Add B to A. Result in A (A = A + B)
RAM[3]: 00111101  ; STORE_A 13  ; Store Result (from A) into RAM[13]
RAM[4]: 11110000  ; HALT        ; Stop program

# Subtraction Program
# Inputs: RAM[14] (Operand 1), RAM[15] (Operand 2)
# Output: RAM[13] (Result)
# (Đặt chương trình này bắt đầu từ RAM[0])

# Opcodes (giả định):
# LOAD_A: 0001xxxx
# LOAD_B: 0010xxxx
# STORE_A: 0011xxxx
# SUB_AB: 01101001
# HALT: 11110000

RAM[0]: 00011110  ; LOAD_A 14   ; Load Operand 1 (RAM[14]) into Register A
RAM[1]: 00101111  ; LOAD_B 15   ; Load Operand 2 (RAM[15]) into Register B
RAM[2]: 01101001  ; SUB_AB      ; Subtract B from A. Result in A (A = A - B)
RAM[3]: 00111101  ; STORE_A 13  ; Store Result (from A) into RAM[13]
RAM[4]: 11110000  ; HALT        ; Stop program

# Multiplication Program
# Inputs: RAM[14] (Multiplicand), RAM[15] (Multiplier)
# Output: RAM[13] (Product)
# (Đặt chương trình này bắt đầu từ RAM[0])

# Memory Map (cho chương trình này):
# RAM[10]: Constant 0
# RAM[11]: Constant 1
# RAM[12]: Result (Product)
# RAM[14]: Multiplicand
# RAM[15]: Multiplier (Used as counter)

# Opcodes (giả định):
# LOAD_A: 0001xxxx
# LOAD_B: 0010xxxx
# STORE_A: 0011xxxx
# STORE_B: 0100xxxx
# ADD_AB: 01011001
# SUB_AB: 01101001
# JUMP: 0111xxxx
# JUMP_ZERO: 1001xxxx
# HALT: 11110000

# Dữ liệu cần đặt trong RAM (ví dụ):
# RAM[10] = 0 (00000000)
# RAM[11] = 1 (00000001)

RAM[0]: 00011010  ; LOAD_A 10   ; Load Constant 0 into Reg A
RAM[1]: 00111100  ; STORE_A 12  ; Store 0 into RAM[12] (Initialize Product = 0)

# Main Loop (Multiplier as counter)
RAM[2]: 00011111  ; LOAD_A 15   ; Load Multiplier (RAM[15]) into Reg A (check if 0)
RAM[3]: 10010111  ; JUMP_ZERO 7 ; If Multiplier is 0 (Z flag), jump to End_Mult (addr 7)

RAM[4]: 00011100  ; LOAD_A 12   ; Load current Product (RAM[12]) into Reg A
RAM[5]: 00101110  ; LOAD_B 14   ; Load Multiplicand (RAM[14]) into Reg B
RAM[6]: 01011001  ; ADD_AB      ; A = Product + Multiplicand
RAM[7]: 00111100  ; STORE_A 12  ; Store new Product into RAM[12]

# Decrement Multiplier
RAM[8]: 00011111  ; LOAD_A 15   ; Load Multiplier into Reg A
RAM[9]: 00101011  ; LOAD_B 11   ; Load Constant 1 (RAM[11]) into Reg B
RAM[10]: 01101001 ; SUB_AB      ; A = Multiplier - 1
RAM[11]: 00111111 ; STORE_A 15  ; Store decremented Multiplier back to RAM[15]

RAM[12]: 01110010 ; JUMP 2      ; Jump back to Main Loop (addr 2)

# End_Mult
RAM[13]: 00011100 ; LOAD_A 12   ; Load final Product from RAM[12] into Reg A
RAM[14]: 00111101 ; STORE_A 13  ; Store final Product into RAM[13] (Output location)
RAM[15]: 11110000 ; HALT        ; Stop program

# Program: Integer Division with Remainder
# Location: RAM[0] - RAM[14]

# Memory Map for this program:
# RAM[10] = Constant 0 (00000000)
# RAM[11] = Constant 1 (00000001)
# RAM[12] = Quotient   (Result: Integer Part of Division)
# RAM[13] = Remainder  (Result: Remainder of Division)
# RAM[14] = Dividend   (Input: Number to be divided)
# RAM[15] = Divisor    (Input: Number to divide by)

# --- Start of Program ---

# Initialization Phase
RAM[0]: 00011110   ; LOAD_A 14     ; Load Dividend from RAM[14] into Reg A (e.g., A = 10)
RAM[1]: 00101010   ; LOAD_B 10     ; Load Constant 0 from RAM[10] into Reg B
RAM[2]: 01001100   ; STORE_B 12    ; Store 0 from Reg B into RAM[12] (Initialize Quotient = 0)

# Division Loop - (Equivalent to 'Loop_Divide' label)
RAM[3]: 00101111   ; LOAD_B 15     ; Load Divisor from RAM[15] into Reg B (e.g., B = 3)
RAM[4]: 01101001   ; SUB_AB        ; Subtract B from A. A = A - B.
RAM[5]: 10001011   ; JUMP_NEG 11   ; If A < 0 (N flag is set), jump to Restore_Remainder (RAM[11])

# Increment Quotient if subtraction was successful (A >= 0)
RAM[6]: 00101100   ; LOAD_B 12     ; Load current Quotient from RAM[12] into Reg B
RAM[7]: 00011011   ; LOAD_A 11     ; Load Constant 1 from RAM[11] into Reg A
RAM[8]: 01011001   ; ADD_AB        ; Add B to A. A = A + B (A now holds current Quotient + 1)
RAM[9]: 00111100   ; STORE_A 12    ; Store updated Quotient from Reg A back into RAM[12]

RAM[10]: 01110011  ; JUMP 3        ; Jump back to the Division Loop (RAM[3])

# Restore Remainder and Store Results - (Equivalent to 'Restore_Remainder' label)
RAM[11]: 00101111  ; LOAD_B 15     ; Load Divisor from RAM[15] back into Reg B
RAM[12]: 01011001  ; ADD_AB        ; Add B to A. A = A + B (This "undoes" the last subtraction, so A now holds the Remainder)
RAM[13]: 00111101  ; STORE_A 13    ; Store Remainder from Reg A into RAM[13]

# End Program
RAM[14]: 11110000  ; HALT          ; Stop the CPU.

# --- Data for Example ---
# Place these values in your RAM before running the program
# RAM[10] = 00000000  (Binary for 0)
# RAM[11] = 00000001  (Binary for 1)
# RAM[14] = 00001010  (Binary for 10 - Dividend)
# RAM[15] = 00000011  (Binary for 3  - Divisor)


#Division with integer and remainder
RAM0   LOAD_A 14
RAM1   STORE_B 12
RAM2   LOAD_B 15
RAM3   SUB_AB
RAM4   JUM_NEG_9
RAM5   LOAD_B_1
RAM6   ADD_AB
RAM7   STORE_B 12
RAM8   JUM_2
RAM9   ADD_AB --
RAM10  STORE_A 13
RAM11  HALT